# paw/canary/server.py
import os, uvicorn, json, hashlib, time, smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from fastapi import FastAPI, Request, Response
from fastapi.responses import HTMLResponse, FileResponse
from ..util.fsutil import ensure_dir, read_json
from ..sentinel.database import CampaignDatabase

def _case_dir(cid): return os.path.join("cases", cid)
def _ev_path(cid): return os.path.join(_case_dir(cid), "canary", "hits.jsonl")
def _fingerprint_path(cid): return os.path.join(_case_dir(cid), "canary", "fingerprints.jsonl")

def send_phishing_alert_email(victim_ip: str, victim_ua: str, phishing_url: str, case_id: str):
    """Send automatic alert email to victim when they click phishing link."""
    try:
        # Email configuration from environment
        smtp_server = os.environ.get("PAW_SMTP_SERVER", "smtp.gmail.com")
        smtp_port = int(os.environ.get("PAW_SMTP_PORT", "587"))
        smtp_user = os.environ.get("PAW_SMTP_USER")
        smtp_pass = os.environ.get("PAW_SMTP_PASS")
        alert_from = os.environ.get("PAW_ALERT_FROM", smtp_user)
        alert_to = os.environ.get("PAW_ALERT_TO")  # If set, send to specific address instead of victim

        if not smtp_user or not smtp_pass:
            print("[canary] Email alert not configured - set PAW_SMTP_USER and PAW_SMTP_PASS")
            return False

        # Create message
        msg = MIMEMultipart()
        msg['From'] = alert_from
        msg['To'] = alert_to or "victim@detected.local"  # Placeholder if no specific recipient
        msg['Subject'] = "üö® ALERT: You Clicked a PHISHING Link!"

        # Email body in ENGLISH (global standard)
        body = f"""
WARNING: Phishing Attempt Detected!

You have just visited a suspicious website that appears to be part of a phishing campaign.

üìä DETECTED DETAILS:
‚Ä¢ URL Visited: {phishing_url}
‚Ä¢ Your IP Address: {victim_ip}
‚Ä¢ Browser/User-Agent: {victim_ua}
‚Ä¢ PAW Case ID: {case_id}
‚Ä¢ Detection Time: {time.strftime('%Y-%m-%d %H:%M:%S UTC', time.gmtime())}

‚ö†Ô∏è IMMEDIATE RECOMMENDATIONS:
1. DO NOT enter any credentials on this site
2. Close your browser immediately
3. Change your passwords if you have any doubts
4. Report this incident to your IT administrator

This alert was automatically generated by the PAW Sentinel system
to protect you from cyber threats.

For more information: https://paw-project.org

---
PAW (Phishing Attribution Workbench) - Automatic Protection
"""

        msg.attach(MIMEText(body, 'plain', 'utf-8'))

        # Send email
        server = smtplib.SMTP(smtp_server, smtp_port)
        server.starttls()
        server.login(smtp_user, smtp_pass)
        text = msg.as_string()
        server.sendmail(alert_from, alert_to or "victim@detected.local", text)
        server.quit()

        print(f"[canary] üö® Alert email sent for phishing click: {victim_ip} -> {phishing_url}")
        return True

    except Exception as e:
        print(f"[canary] Failed to send alert email: {e}")
        return False

def run_canary(case_id: str, port: int=8787):
    ensure_dir(os.path.dirname(_ev_path(case_id)))
    ensure_dir(os.path.dirname(_fingerprint_path(case_id)))
    
    app = FastAPI()

    # Load URLs from case headers
    headers_path = os.path.join(_case_dir(case_id), "headers.json")
    urls = []
    if os.path.exists(headers_path):
        headers = read_json(headers_path) or {}
        urls = headers.get("urls", [])
    
    # Load HTML templates
    template_dir = os.path.join(os.path.dirname(__file__), "templates")
    
    def load_template(filename):
        template_path = os.path.join(template_dir, filename)
        if os.path.exists(template_path):
            with open(template_path, "r", encoding="utf-8") as f:
                return f.read()
        return "<html><body>Template not found</body></html>"
    
    login_template = load_template("fingerprint_login.html")
    verified_template = load_template("verified.html")
    
    # Create interactive honeypot endpoints for each URL
    for url in urls:
        from urllib.parse import urlparse
        parsed = urlparse(url)
        path = parsed.path or "/"
        if path == "/":
            path = "/phish"
        
        # Remove leading slash for route
        route_path = path.lstrip("/")
        
        async def create_honeypot_endpoint(request: Request, url=url):
            """Serve the interactive login page with fingerprinting."""
            # Log the visit
            ua = request.headers.get("user-agent","")
            ip = request.client.host
            now = int(time.time())
            rec = {"ts": now, "ip": ip, "ua": ua, "url": url, "action": "page_visit"}
            with open(_ev_path(case_id), "a", encoding="utf-8") as f:
                f.write(json.dumps(rec)+"\n")

            # ÔøΩ VICTIM INTELLIGENCE: Save to database for attacker localization
            try:
                db = CampaignDatabase()
                victim_metadata = {
                    "headers": dict(request.headers),
                    "method": request.method,
                    "path": request.url.path,
                    "query_params": str(request.url.query),
                    "client_host": ip,
                    "user_agent": ua,
                    "timestamp": now
                }
                victim_id = db.add_victim_intelligence(
                    victim_ip=ip,
                    victim_ua=ua,
                    phishing_url=url,
                    case_id=case_id,
                    metadata=victim_metadata
                )
                print(f"[canary] üéØ Victim intelligence captured - ID: {victim_id}, IP: {ip}")
            except Exception as e:
                print(f"[canary] ‚ùå Failed to save victim intelligence: {e}")

            # ÔøΩüö® ATOMIC IDEA: Send automatic alert email to victim!
            send_phishing_alert_email(ip, ua, url, case_id)
            
            # Return the login page
            return HTMLResponse(content=login_template, status_code=200)
        
        app.add_api_route(f"/{route_path}", create_honeypot_endpoint, methods=["GET"])
    
    # Endpoint for receiving fingerprint data
    @app.post("/fingerprint")
    async def receive_fingerprint(request: Request):
        try:
            data = await request.json()
            ip = request.client.host
            ua = request.headers.get("user-agent","")
            now = int(time.time())
            
            # Add metadata
            data["ip"] = ip
            data["user_agent"] = ua
            data["received_at"] = now
            
            # Save fingerprint data
            with open(_fingerprint_path(case_id), "a", encoding="utf-8") as f:
                f.write(json.dumps(data)+"\n")
            
            return {"status": "fingerprint_received"}
        except Exception as e:
            return {"status": "error", "message": str(e)}
    
    # Endpoint for verification completion
    @app.get("/verified")
    async def verified_page(request: Request):
        """Serve the success page."""
        ip = request.client.host
        ua = request.headers.get("user-agent","")
        now = int(time.time())
        
        rec = {"ts": now, "ip": ip, "ua": ua, "action": "verification_complete"}
        with open(_ev_path(case_id), "a", encoding="utf-8") as f:
            f.write(json.dumps(rec)+"\n")
        
        return HTMLResponse(content=verified_template, status_code=200)
    
    @app.post("/verified")
    async def verified_post(request: Request):
        """Handle verification completion POST."""
        try:
            data = await request.json()
            ip = request.client.host
            ua = request.headers.get("user-agent","")
            now = int(time.time())
            
            data["ip"] = ip
            data["user_agent"] = ua
            data["received_at"] = now
            
            with open(_ev_path(case_id), "a", encoding="utf-8") as f:
                f.write(json.dumps(data)+"\n")
            
            return {"status": "verification_logged"}
        except Exception as e:
            return {"status": "error", "message": str(e)}
    
    # Legacy token endpoint (for backward compatibility)
    @app.get("/t/{token}")
    async def t_endpoint(token: str, request: Request):
        ua = request.headers.get("user-agent","")
        ip = request.client.host
        now = int(time.time())
        rec = {"ts": now, "ip": ip, "ua": ua, "token": token}
        with open(_ev_path(case_id), "a", encoding="utf-8") as f:
            f.write(json.dumps(rec)+"\n")
        return HTMLResponse(content=login_template, status_code=200)
    
    # Injected canary links endpoint
    @app.get("/c/{token}")
    async def canary_link_endpoint(token: str, request: Request):
        """Handle injected canary links for URL-less phishing."""
        ua = request.headers.get("user-agent","")
        ip = request.client.host
        now = int(time.time())
        
        # Log the canary hit
        rec = {"ts": now, "ip": ip, "ua": ua, "token": token, "action": "canary_link_hit", "injected": True}
        with open(_ev_path(case_id), "a", encoding="utf-8") as f:
            f.write(json.dumps(rec)+"\n")

        # ÔøΩ VICTIM INTELLIGENCE: Save to database for attacker localization
        try:
            db = CampaignDatabase()
            victim_metadata = {
                "headers": dict(request.headers),
                "method": request.method,
                "token": token,
                "injected_link": True,
                "client_host": ip,
                "user_agent": ua,
                "timestamp": now
            }
            victim_id = db.add_victim_intelligence(
                victim_ip=ip,
                victim_ua=ua,
                phishing_url=f"canary_token_{token}",
                case_id=case_id,
                metadata=victim_metadata
            )
            print(f"[canary] üéØ Victim intelligence captured - ID: {victim_id}, IP: {ip} (injected link)")
        except Exception as e:
            print(f"[canary] ‚ùå Failed to save victim intelligence: {e}")

        # ÔøΩüö® ATOMIC IDEA: Send automatic alert email to victim!
        send_phishing_alert_email(ip, ua, f"canary_token_{token}", case_id)
        
        # Return the login page
        return HTMLResponse(content=login_template, status_code=200)

    @app.get("/")
    async def root():
        return {"status": "canary up", "case": case_id, "urls": urls}

    print(f"[canary] http://0.0.0.0:{port}/ serving {len(urls)} URLs for case {case_id}")
    uvicorn.run(app, host="0.0.0.0", port=port, log_level="warning")